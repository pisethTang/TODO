Controller-specific JSDoc Practices 
- Every controller should have a JSDoc block. 
- Describe parameters, their types and purpose. 
- Describe return values 
- Mention thrown errorsa: any potential errors the function may throw, which aids in safe error handling. 
- provide examples: incloude a brief code snipper demonstrating how to use the function, which is particularly helpful complex operations. 
- use typedef for complex objects: if the controller deals with complex data structure 


Core Principles
- Prioritize Clean Code: Strive to write code that is largely self-explanatory through meaningful function, variable, and file names. Complex logic should be broken into smaller, well-named functions.
- Document the "Why," not the "What": Use comments to explain why a particular approach was taken, especially for non-obvious optimizations or "hacks," rather than simply restating what the code does.
- Consistency is Key: Adhere to consistent naming conventions and documentation styles across your entire codebase to reduce the cognitive load for developers.



API-Level Documentation (OpenAPI/Swagger)
- For web APIs, inline code documentation with JSDoc only tells half the story. Tools that generate external API documentation are essential for consumers of your API (frontend developers, third parties).
Generate an OpenAPI Specification: Tools like Swagger or Tspec can automatically parse your code (or a separate spec file) to create an OpenAPI specification and a beautiful, interactive user interface (Swagger UI).

- Focus on the Contract: This documentation focuses on API endpoints, HTTP methods (GET, POST, etc.), request/response bodies, status codes, and authentication methods. It describes the API's contract with clients, rather than the internal implementation details.

/**
 * Fetches a user by their unique ID.
 * @param {object} req - The Express request object.
 * @param {object} res - The Express response object.
 * @param {Function} next - The Express next middleware function.
 * @returns {Promise<void>} A promise that resolves when the response is sent.
 * @throws {Error} If the user is not found or a server error occurs.
 * @example
 * router.get('/users/:id', userController.getUserById);
 */
async function getUserById(req, res, next) {
  try {
    const { id } = req.params;
    // ... logic to fetch user ...
    res.status(200).json(user);
  } catch (error) {
    next(error); // Pass error to centralized error handler
  }
}


